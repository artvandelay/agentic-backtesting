=== METADATA ===
timestamp: 2025-10-06 05:28:08.342756
run_dir: reports/AAPL_2024_20251006_052718
git_sha: 1590dc9a306f3b621696de77442d7b841579c4b5

=== CODEBASE ===
--- src/nlbt/reflection.py ---
"""Minimal 3-phase reflection engine."""

import os
import logging
import glob
from datetime import datetime
from .llm import LLM
from .sandbox import Sandbox


def setup_run_logging(run_dir):
    """Setup debug and agent loggers for this run."""
    # Developer trace logger
    debug = logging.getLogger(f'debug_{run_dir}')
    debug.setLevel(logging.INFO)
    debug.addHandler(logging.FileHandler(f'{run_dir}/debug.log'))
    
    # Agent context logger
    agent = logging.getLogger(f'agent_{run_dir}')
    agent.setLevel(logging.INFO)
    agent.addHandler(logging.FileHandler(f'{run_dir}/agent.log'))
    
    return debug, agent


class ReflectionEngine:
    """
    3-phase autonomous backtest workflow.
    
    Phase 1: Understanding - LLM asks until STATUS: READY
    Phase 2: Implementation - Producer/Critic loop
    Phase 3: Reporting - Plan/Write/Refine
    """
    
    def __init__(self, model: str = None):
        self.llm = LLM(model)
        # Use strong model for code generation
        # Use advanced model for code generation - try Claude first, fallback to GPT-4.5
        # Allow environment override; prefer Claude if explicitly set
        code_model = (
            os.getenv("LLM_CODE_MODEL")
            or "openrouter/anthropic/claude-3.5-sonnet"
        )
        try:
            self.code_llm = LLM(code_model)
        except Exception:
            # Fallback to an advanced OpenAI model if available
            self.code_llm = LLM("gpt-4.5-preview")
        self.sandbox = Sandbox()
        self.phase = "understanding"
        self.history = []
        self.requirements = {}
        self.code = ""
        self.results = ""
        self.last_error = ""
        # Last validator decision for debugging
        self.last_validation = None
        # Loggers (initialized in phase 3 when run_dir is created)
        self.debug_logger = None
        self.agent_logger = None
    
    def chat(self, user_input: str) -> str:
        """Process user message, return agent response."""
        
        # CRITICAL: Don't process empty or whitespace-only inputs
        if not user_input or not user_input.strip():
            return "Please provide a message."
        
        user_input = user_input.strip()
        self.history.append(f"User: {user_input}")
        
        # Check if user wants to change requirements during implementation
        if self.phase == "implementation" and any(word in user_input.lower() for word in ["sorry", "actually", "i mean", "change"]):
            # Go back to understanding phase
            self.phase = "understanding"
            return "I see you want to change the requirements. Let me understand what you need.\n\n" + self._phase1_understanding(user_input)
        
        if self.phase == "understanding":
            response = self._phase1_understanding(user_input)
        elif self.phase == "ready_to_implement":
            response = self._handle_implementation_confirmation(user_input)
        elif self.phase == "implementation":
            # Implementation should not be triggered by user input anymore
            # It's handled directly in _handle_implementation_confirmation
            return "âœ… Implementation already completed. Type 'info' to see current status or start a new strategy."
        elif self.phase == "reporting":
            # Reporting should execute immediately, not wait for input
            return self._phase3_reporting()
        elif self.phase == "complete":
            # Reset to understanding for new conversation
            self.phase = "understanding"
            response = "ðŸŽ¯ Previous conversation completed! Ready for new strategy. What would you like to backtest?"
        else:
            response = "All done!"
        
        self.history.append(f"Agent: {response}")
        return response
    
    def _phase1_understanding(self, user_input: str, from_confirmation: bool = False) -> str:
        """Phase 1: Gather requirements until LLM says READY."""
        
        # First, try to extract requirements from the conversation
        self._update_requirements_from_conversation(user_input)
        
        prompt = f"""You are helping gather backtesting requirements. Have a natural conversation.

CONVERSATION HISTORY:
{self._get_history()}

CURRENT USER MESSAGE: {user_input}

REQUIRED INFO (track what you have):
- Ticker symbol (e.g., AAPL, MSFT, SPY)
- Time period (e.g., "2020 to 2024", "last 2 years", "2023")  
- Initial capital (e.g., "$10,000", "$25K", "50000")
- Strategy description (trading rules and logic)

CRITICAL INSTRUCTIONS:
1. Have a NATURAL conversation - don't repeat the same format
2. NEVER make up or imagine user messages - only respond to what they actually said
3. If you have some info already, acknowledge it and ask for what's missing
4. Be conversational: "Great! I have the ticker as TSLA and strategy as buying on Mondays. What time period and capital should I use?"
5. When you have ALL 4 requirements (ticker, period, capital, strategy), IMMEDIATELY output STATUS: READY format
6. Don't ask for unnecessary details if you already have enough info
7. If user provides a complete strategy description, don't ask for more details unless absolutely needed

STATUS FORMAT (use ONLY when you have everything):

STATUS: READY
TICKER: [value]
PERIOD: [value] 
CAPITAL: [value]
STRATEGY: [complete description]

I have everything needed to proceed with the backtest.

ðŸ’¡ USER TIP: You can say "yes", "go", or "proceed" when ready, or make changes anytime!

RESPOND ONLY to the current user message. Do NOT create fake conversations."""

        response = self.llm.ask(prompt)
        
        # Clean the response - remove any fake "User:" or "Agent:" prefixes that LLM might add
        response = response.strip()
        if response.startswith("User:") or response.startswith("Agent:"):
            # LLM is hallucinating - extract just the actual response
            lines = response.split('\n')
            clean_lines = []
            for line in lines:
                if not line.strip().startswith("User:") and not line.strip().startswith("Agent:"):
                    clean_lines.append(line)
            response = '\n'.join(clean_lines).strip()
        
        # Check if we have all 4 requirements from extraction
        has_ticker = bool(self.requirements.get('ticker'))
        has_period = bool(self.requirements.get('period'))
        has_capital = bool(self.requirements.get('capital'))
        has_strategy = bool(self.requirements.get('strategy'))

        # If we have all requirements, validate against scaffold before READY
        # BUT skip auto-proceed if we're coming from confirmation step
        if has_ticker and has_period and has_capital and has_strategy and not from_confirmation:
            validation = self._validate_requirements_with_codebase()
            self.last_validation = validation
            if validation.get("implementable"):
                # Auto-proceed immediately (agentic flow)
                self.phase = "implementation"
                return self._phase2_implementation()
            else:
                clar = validation.get("clarifications") or []
                # Synthesize concrete clarifications if missing
                if not clar:
                    missing = []
                    for k in ["ticker", "period", "capital", "strategy"]:
                        if not self.requirements.get(k):
                            missing.append(k)
                    for k in missing:
                        if k == "ticker":
                            clar.append("Specify a single ticker (e.g., AAPL or RELIANCE.NS)")
                        elif k == "period":
                            clar.append("Provide a concrete period (e.g., 2023 or 2020-2024)")
                        elif k == "capital":
                            clar.append("Provide initial capital with currency (e.g., $10,000 or â‚¹10,00,000)")
                        elif k == "strategy":
                            clar.append("Describe entry and exit rules with numeric thresholds")
                clar_block = "\n".join([f"- {c}" for c in clar]) if clar else "- Please clarify missing or vague details so I can proceed."
                return f"""âš ï¸ Before I can proceed, I need a few clarifications to ensure this strategy is implementable with the current system:\n{clar_block}\n\nPlease answer these in one message."""

        # Check if LLM says READY
        if "STATUS: READY" in response:
            self._extract_requirements(response)
            validation = self._validate_requirements_with_codebase()
            self.last_validation = validation
            if validation.get("implementable"):
                # Auto-proceed directly
                self.phase = "implementation"
                return self._phase2_implementation()
            else:
                clar = validation.get("clarifications") or []
                if not clar:
                    missing = []
                    for k in ["ticker", "period", "capital", "strategy"]:
                        if not self.requirements.get(k):
                            missing.append(k)
                    for k in missing:
                        if k == "ticker":
                            clar.append("Specify a single ticker (e.g., AAPL or RELIANCE.NS)")
                        elif k == "period":
                            clar.append("Provide a concrete period (e.g., 2023 or 2020-2024)")
                        elif k == "capital":
                            clar.append("Provide initial capital with currency (e.g., $10,000 or â‚¹10,00,000)")
                        elif k == "strategy":
                            clar.append("Describe entry and exit rules with numeric thresholds")
                clar_block = "\n".join([f"- {c}" for c in clar]) if clar else "- Please clarify missing or vague details so I can proceed."
                return f"""âš ï¸ Before I can proceed, I need a few clarifications to ensure this strategy is implementable with the current system:\n{clar_block}\n\nPlease answer these in one message."""
        
        return response
    
    def _handle_implementation_confirmation(self, user_input: str) -> str:
        """Handle user confirmation before starting implementation."""
        user_lower = user_input.lower().strip()
        
        # Check for proceed signals (whole word matching)
        import re
        proceed_words = ["yes", "go", "proceed", "ok", "start", "continue"]
        proceed_pattern = r'\b(' + '|'.join(proceed_words) + r')\b'
        
        # Check for conflicting words that indicate it's not a simple proceed
        conflict_words = ["but", "change", "explain", "first", "wait", "think", "over", "else"]
        has_conflict = any(word in user_lower for word in conflict_words)
        
        if re.search(proceed_pattern, user_lower) and not has_conflict:
            # Proceed if we have a proceed word AND no conflicting words
            self.phase = "implementation"
            
            # Immediately start implementation instead of just showing a message
            implementation_result = self._phase2_implementation()
            return implementation_result
        
        # Everything else goes back to understanding phase
        # The understanding phase LLM is smart enough to handle:
        # - "change ticker to TSLA" 
        # - "explain how RSI works"
        # - "actually use 2023 instead"
        # - "reset everything"
        # - "what does this strategy do?"
        self.phase = "understanding"
        return "Got it! Let me help you with that.\n\n" + self._phase1_understanding(user_input, from_confirmation=True)
    
    def _phase2_implementation(self, attempt: int = 1) -> str:
        """Phase 2: Producer generates, Critic evaluates."""
        if attempt > 3:
            if self.debug_logger:
                self.debug_logger.info(f"Failed after 3 attempts. Last error: {self.last_error}")
            
            # Return to understanding phase with full context
            self.phase = "understanding"
            error_msg = f"âŒ Failed after 3 attempts.\n\nLast error:\n{self.last_error}\n\nLet's try a different approach."
            return error_msg + "\n\n" + self._phase1_understanding("I need help fixing this strategy", from_confirmation=True)
        
        print(f"ðŸ”„ Attempt {attempt}/3 - Generating/Testing/Executing...")
        if self.debug_logger:
            self.debug_logger.info(f"Attempt {attempt}/3 - Generating/Testing/Executing...")
        
        # Producer: Generate code with BULLETPROOF template
        if attempt == 1:
            code_prompt = f"""Generate complete Python backtesting code. Copy this EXACT pattern:

REQUIREMENTS:
{self._format_requirements()}

BULLETPROOF CODE TEMPLATE (copy this structure exactly):

```python
from backtesting import Backtest, Strategy

# Get data (NEVER redefine get_ohlcv_data - it exists!)
data = get_ohlcv_data('TICKER', 'START_DATE', 'END_DATE')

class MyStrategy(Strategy):
    def init(self):
        # For indicators, use this EXACT pattern:
        # Step 1: Define helper that returns numpy array
        def sma(values, n):
            import pandas as pd
            return pd.Series(values).rolling(n).mean().to_numpy()
        
        # Step 2: Wrap with self.I
        # self.sma20 = self.I(sma, self.data.Close, 20)
        # self.sma50 = self.I(sma, self.data.Close, 50)
        
        pass
    
    def next(self):
        # Trading logic here
        if not self.position:
            self.buy()

bt = Backtest(data, MyStrategy, cash=CASH_NUMBER)
stats = bt.run()
print(stats)

# Emit structured artifacts for reporting
import json
try:
    # Trades preview table
    import pandas as pd
    print("TRADES_TABLE")
    print(stats._trades.head(20).to_markdown(index=False))
except Exception:
    pass

# Full CSVs for optional charts/tables
try:
    import pandas as pd
    print("TRADES_CSV"); print(stats._trades.to_csv(index=False))
    print("EQUITY_CSV"); print(stats._equity_curve.to_csv(index=False))
except Exception:
    pass

# Compact summary for TL;DR
try:
    end_date = str(stats.get('End', '')) or (str(data.index[-1].date()) if hasattr(data, 'index') and len(data.index) else '')
    equity_final = float(stats.get('Equity Final [$]', 0))
    initial_cap = float(CASH_NUMBER)
    pnl_abs = equity_final - initial_cap
    pnl_pct = float(stats.get('Return [%]', 0))
    print("SUMMARY_JSON"); print(json.dumps(dict(
        end=end_date,
        initial=initial_cap,
        equity_final=equity_final,
        portfolio_final=equity_final,
        pnl_abs=pnl_abs,
        pnl_pct=pnl_pct
    )))
except Exception:
    pass
```

PATTERN FOR INDICATORS (copy exactly):

RSI:
```
def rsi(values, n=14):
    import pandas as pd
    import numpy as np
    delta = pd.Series(values).diff()
    gain = (delta.where(delta > 0, 0)).rolling(n).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(n).mean()
    rs = gain / loss
    return (100 - (100 / (1 + rs))).to_numpy()

self.rsi = self.I(rsi, self.data.Close, 14)
```

SMA:
```
def sma(values, n):
    import pandas as pd
    return pd.Series(values).rolling(n).mean().to_numpy()

self.sma20 = self.I(sma, self.data.Close, 20)
```

MACD:
```
def ema(values, n):
    import pandas as pd
    return pd.Series(values).ewm(span=n, adjust=False).mean().to_numpy()

def macd(values):
    ema12 = ema(values, 12)
    ema26 = ema(values, 26)
    return ema12 - ema26

def macd_signal(values):
    import pandas as pd
    macd_line = macd(values)
    return pd.Series(macd_line).ewm(span=9, adjust=False).mean().to_numpy()

self.macd = self.I(macd, self.data.Close)
self.macd_signal = self.I(macd_signal, self.data.Close)
```

CROSSOVER (for MA strategies):
```
# In next():
if self.sma20[-2] <= self.sma50[-2] and self.sma20[-1] > self.sma50[-1]:
    if not self.position:
        self.buy()
```

YOUR TASK:
1. Replace TICKER with: {self.requirements.get('ticker', 'AAPL')}
2. Replace START_DATE, END_DATE based on: {self.requirements.get('period', '2024')}
   IMPORTANT: If using indicators with long windows (200-day SMA, etc.), START EARLIER to allow warmup.
   Example: For "2023-2024", use '2022-01-01' to '2024-12-31' to ensure 200-day SMA has data.
3. Replace CASH_NUMBER with a pure number (e.g., 10000). If capital is given as text like 'â‚¹10,00,000' or '$10,000', convert to number.
4. Implement strategy: {self.requirements.get('strategy', 'buy and hold')}
5. Use indicator patterns above if needed

Write ONLY the complete code (no markdown, no explanations):"""
            
            response = self.code_llm.ask(code_prompt)
            if "```python" in response:
                self.code = response.split("```python")[1].split("```")[0].strip()
            else:
                self.code = response.strip()
        
        # Execute
        result = self.sandbox.run(self.code)
        
        if self.debug_logger:
            self.debug_logger.info(f"Execution result: {'SUCCESS' if result['success'] else 'FAILED'}")
            if result["success"]:
                self.debug_logger.info(f"Output:\n{result['output']}")
            else:
                self.debug_logger.info(f"Error:\n{result['error']}")
        
        if not result["success"]:
            self.last_error = result["error"]
            
            # Fix prompt with specific error context
            fix_prompt = f"""Fix this error. Use the indicator patterns from before.

ERROR:
{result['error']}

CODE:
{self.code}

REQUIREMENTS:
{self._format_requirements()}

CRITICAL FIXES:
1. NEVER redefine get_ohlcv_data - it exists!
2. cash must be a number: cash=10000 NOT cash='$10,000'
3. Dates: '2024-01-01' format
4. For indicators, use the helper function pattern shown earlier
5. All indicators must return .to_numpy()
6. At the end, print TRADES_CSV and EQUITY_CSV exactly as shown:
   print("TRADES_CSV"); print(stats._trades.to_csv(index=False)); print("EQUITY_CSV"); print(stats._equity_curve.to_csv(index=False))

Write the COMPLETE fixed code:"""
            
            response = self.code_llm.ask(fix_prompt)
            if "```python" in response:
                self.code = response.split("```python")[1].split("```")[0].strip()
            else:
                self.code = response.strip()
            
            return self._phase2_implementation(attempt + 1)
        
        # Critic: Evaluate
        self.results = result["output"]
        
        critique_prompt = f"""Evaluate: Did the backtest run successfully?

Requirements: {self._format_requirements()}
Results: {self.results}

PASS if: 
- Shows stats (Return %, Equity Final, etc.)
- Uses correct ticker/period/capital
- No crashes or errors
- Even if # Trades = 0 (strategy may not trigger signals in this period)

FAIL if: 
- Crashed with errors
- Wrong ticker/period/capital
- No stats shown

DECISION: [PROCEED or RETRY]"""

        critique = self.code_llm.ask(critique_prompt)
        
        if self.debug_logger:
            self.debug_logger.info(f"Critic decision: {'PROCEED' if 'PROCEED' in critique.upper() else 'RETRY'}")
        
        if "PROCEED" in critique.upper():
            self.phase = "reporting"
            # Lightweight LLM TL;DR from stats
            summary_line = self._llm_tldr(self.results)
            # Generate report but keep CLI output minimal
            report_msg = self._phase3_reporting()
            # Extract folder path line for concise echo
            folder_line = ""
            for ln in report_msg.splitlines():
                if ln.startswith("ðŸ“„ REPORT FOLDER:"):
                    folder_line = ln
                    break
            return f"ðŸ§¾ {summary_line}\n{folder_line}"
        else:
            return self._phase2_implementation(attempt + 1)
    
    def _create_implementation_plan(self) -> dict:
        """Create a detailed implementation plan before coding."""
        planning_prompt = f"""You are a senior backtesting engineer creating a detailed implementation plan.

REQUIREMENTS:
{self._format_requirements()}

Following the Agentic Design Patterns principles, create a comprehensive plan:

1. STRATEGY ANALYSIS (Pattern: Planning):
   - Strategy type: buy-and-hold, mean reversion, momentum, breakout, etc.
   - Entry conditions: precise logic for when to buy
   - Exit conditions: precise logic for when to sell/close positions
   - Risk management: stop losses, position sizing, etc.

2. INDICATOR REQUIREMENTS (Pattern: Tool Use):
   - Technical indicators needed with exact parameters
   - How to calculate each in backtesting.py context
   - Alternative implementations if libraries differ

3. CODE ARCHITECTURE (Pattern: Reflection):
   - Strategy class structure following backtesting.py patterns
   - init() method: indicator initialization with error handling
   - next() method: trading logic with position management
   - Helper methods for complex calculations

4. IMPORT STRATEGY (Pattern: Tool Use):
   - Correct imports from backtesting library
   - Correct imports from ta library (ta.momentum, ta.trend, etc.)
   - Any additional libraries needed

5. RISK ANALYSIS (Pattern: Exception Handling):
   - Common failure modes for this strategy type
   - Edge cases: market closures, data gaps, extreme volatility
   - Recovery strategies for each failure mode

6. TESTING APPROACH (Pattern: Evaluation):
   - Component testing before full backtest
   - Expected behavior validation
   - Performance metrics to validate

Provide a structured, actionable plan that follows agentic patterns:"""

        try:
            response = self.code_llm.ask(planning_prompt)
            # Store the plan for reference
            self.implementation_plan = response
            return {"success": True, "plan": response}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def _generate_code_from_plan(self, attempt: int) -> str:
        """Generate code based on the implementation plan."""
        if attempt == 1:
            # First attempt: use the detailed plan
            code_prompt = f"""You are a senior backtesting engineer implementing a strategy following agentic design patterns.

DETAILED IMPLEMENTATION PLAN:
{getattr(self, 'implementation_plan', 'No plan available')}

REQUIREMENTS:
{self._format_requirements()}

FOLLOWING AGENTIC PATTERNS:
â€¢ Use proper imports from ta library (ta.momentum, ta.trend, etc.)
â€¢ Structure code with clear Strategy class following backtesting.py patterns
â€¢ Include error handling and edge case management
â€¢ Use proper indicator calculations with ta library
â€¢ Implement position management and risk controls

CODE REQUIREMENTS:
1. EXACT imports: Use ta.momentum for RSI, ta.trend for SMA/MACD
2. Data handling: Use existing get_ohlcv_data() function
3. Strategy structure: Proper init() and next() methods
4. Error handling: Handle data issues, calculation errors
5. Risk management: Implement stop losses, position sizing

INDICATOR INTEGRATION WITH backtesting.Strategy:
- In init(), ALWAYS create indicators via self.I with a lambda that returns a NumPy array
- Convert pandas Series to numpy with .to_numpy()
- Example SMA:
  from ta.trend import SMAIndicator
  import pandas as pd
  self.sma20 = self.I(lambda c: SMAIndicator(close=pd.Series(c), window=20).sma_indicator().to_numpy(), self.data.Close)
  self.sma50 = self.I(lambda c: SMAIndicator(close=pd.Series(c), window=50).sma_indicator().to_numpy(), self.data.Close)
- Example RSI:
  from ta.momentum import RSIIndicator
  import pandas as pd
  self.rsi = self.I(lambda c: RSIIndicator(close=pd.Series(c), window=14).rsi().to_numpy(), self.data.Close)
- Example MACD (returns MACD line):
  from ta.trend import MACD
  import pandas as pd
  self.macd = self.I(lambda c: MACD(close=pd.Series(c), window_slow=26, window_fast=12, window_sign=9).macd().to_numpy(), self.data.Close)
  self.macd_signal = self.I(lambda c: MACD(close=pd.Series(c), window_slow=26, window_fast=12, window_sign=9).macd_signal().to_numpy(), self.data.Close)
  # In next(), detect cross without importing backtesting.lib:
  # bullish_cross = (self.macd[-2] <= self.macd_signal[-2]) and (self.macd[-1] > self.macd_signal[-1])

CRITICAL FIXES:
- Use 'from ta.trend import MACD' NOT 'from backtesting.test import MACD'
- Use 'from ta.momentum import RSIIndicator' NOT 'from backtesting.test import RSI'
- MACD calculation: macd = MACD(close=data.Close, window_slow=26, window_fast=12, window_sign=9).macd()
- RSI calculation: rsi = RSIIndicator(close=data.Close, window=14).rsi()
- Do NOT use pandas_ta â€” use the 'ta' library imports shown above

Generate ONLY the complete, executable Python code:"""
        else:
            # Retry attempts: focus on fixing the specific error
            code_prompt = f"""Fix the code based on this error:

PREVIOUS CODE:
{self.code}

ERROR:
{self.last_error}

REQUIREMENTS:
{self._format_requirements()}

COMMON FIXES:
- ImportError for RSI: Use 'from ta.momentum import RSIIndicator' and integrate via self.I, e.g. in init():
    self.rsi = self.I(lambda c: RSIIndicator(close=pd.Series(c), window=14).rsi().to_numpy(), self.data.Close)
- ImportError for SMA: Use 'from ta.trend import SMAIndicator' and compute with ta, integrated via self.I
- ImportError for MACD: Use 'from ta.trend import MACD' and integrate via self.I, e.g.:
    self.macd = self.I(lambda c: MACD(close=pd.Series(c), window_slow=26, window_fast=12, window_sign=9).macd().to_numpy(), self.data.Close)
- Cash error: Ensure cash=NUMBER (not cash='$10,000')
- Date format: Use 'YYYY-MM-DD' strings
- Never import from 'backtesting.test' - use 'ta' library instead
 - Do NOT use pandas_ta; only use the 'ta' package

Write the COMPLETE corrected code:"""

        try:
            response = self.code_llm.ask(code_prompt)
            # Extract code from markdown
            if "```python" in response:
                code = response.split("```python")[1].split("```")[0].strip()
            else:
                code = response.strip()
            
            self.code = code
            return code
        except Exception as e:
            self.last_error = str(e)
            return None
    
    def _test_code_components(self, code: str) -> dict:
        """Test basic code components before full execution."""
        try:
            # Basic syntax check
            compile(code, '<string>', 'exec')
            
            # Check for common issues
            issues = []
            if 'def get_ohlcv_data' in code:
                issues.append("Code redefines get_ohlcv_data() - should use existing function")
            
            forbidden = [
                'from backtesting.test import RSI',
                'from backtesting.test import MACD',
                'from backtesting.test import SMA',
                'import pandas_ta',
                'from pandas_ta',
            ]
            for bad in forbidden:
                if bad in code:
                    issues.append("Do not import indicators from backtesting.test - use ta library")
                
            if issues:
                return {"success": False, "error": "; ".join(issues)}
                
            return {"success": True}
        except SyntaxError as e:
            return {"success": False, "error": f"Syntax error: {e}"}
        except Exception as e:
            return {"success": False, "error": f"Code validation error: {e}"}

    def _get_scaffold_context(self) -> str:
        """Assemble minimal scaffold context for validator prompt."""
        import os
        base_dir = os.path.dirname(__file__)
        parts = []
        # sandbox.py (short, safe to include entirely)
        try:
            with open(os.path.join(base_dir, 'sandbox.py'), 'r', encoding='utf-8') as f:
                parts.append("SANDBOX.PY:\n" + f.read())
        except Exception:
            pass
        # reflection head and _test_code_components
        try:
            with open(os.path.join(base_dir, 'reflection.py'), 'r', encoding='utf-8') as f:
                refl = f.read()
            head = "\n".join(refl.splitlines()[:150])
            parts.append("REFLECTION.PY (HEAD):\n" + head)
            marker = "def _test_code_components"
            idx = refl.find(marker)
            if idx != -1:
                snippet = refl[idx:]
                parts.append("REFLECTION.PY (_test_code_components):\n" + "\n".join(snippet.splitlines()[:120]))
        except Exception:
            pass
        return "\n\n".join(parts)

    def _validate_requirements_with_codebase(self) -> dict:
        """Use LLM to validate whether current requirements are implementable.

        Returns: {"implementable": bool, "clarifications": list[str], "raw": str}
        """
        scaffold = self._get_scaffold_context()
        req = self.requirements.copy()
        prompt = (
            "You are validating if the strategy is implementable using this scaffold.\n"
            "Respond concisely with deterministic headers.\n\n"
            "# VALIDATION RULES (code-like, hard constraints)\n"
            "supports_single_ticker = True\n"
            "supports_multi_asset = False\n"
            "supports_options = False\n"
            "requires_numeric_thresholds = True  # e.g. 'dips' must include % or window\n\n"
            "# Heuristics (pseudo)\n"
            "def contains_multiple_tickers(text):\n"
            "    import re\n"
            "    # two distinct tickers like 'GLD and SPY'\n"
            "    return bool(re.search(r'\\b[A-Z]{2,5}\\b.*\\b[A-Z]{2,5}\\b', text)) and (' & ' in text or ' and ' in text or ',' in text)\n\n"
            "def mentions_options(text):\n"
            "    t = text.lower()\n"
            "    return any(w in t for w in ['option', 'iron condor', 'straddle', 'strangle', 'call', 'put', 'spread'])\n\n"
            "def vague_without_numbers(text):\n"
            "    import re\n"
            "    t = text.lower()\n"
            "    vague_terms = ['dip', 'dips', 'momentum', 'breakout', 'retrace', 'bounce']\n"
            "    has_vague = any(v in t for v in vague_terms)\n"
            "    has_numbers = bool(re.search(r'\\d+\\s*%|\\d+\\s*(day|bar|period|window)', t))\n"
            "    return has_vague and not has_numbers\n\n"
            "def clearly_numeric_strategy(text):\n"
            "    t = text.lower()\n"
            "    # Examples: 'RSI < 30 and > 70', 'EMA 10 crosses 20', '5% drop'\n"
            "    return any(k in t for k in ['rsi', 'ema', 'sma', '%'])\n\n"
            f"REQUIREMENTS:\n{req}\n\n"
            f"SCAFFOLD:\n{scaffold}\n\n"
            "# DECISION LOGIC\n"
            "# If multi-asset or options mentioned â†’ IMPLEMENTABLE: NO\n"
            "# If vague triggers without numeric thresholds â†’ IMPLEMENTABLE: NO, but suggest concrete defaults\n"
            "# If single ticker and rules are clearly numeric/precise â†’ IMPLEMENTABLE: YES\n\n"
            "Output exactly this format:\n"
            "IMPLEMENTABLE: YES|NO\n"
            "If NO, then follow with:\n"
            "CLARIFICATIONS:\n"
            "- Ask to choose a single ticker if multiple tickers are present\n"
            "- Ask to avoid options/derivatives; propose stock-based alternative\n"
            "- Ask for numeric thresholds/windows for vague terms (e.g., dips %)\n"
            "- Provide one concrete suggestion when helpful (e.g., 'dip = 5% below 10-day EMA; sell on cross above')\n"
            "- Up to 5 bullets total\n"
        )
        try:
            resp = self.llm.ask(prompt)
        except Exception as e:
            return {"implementable": False, "clarifications": ["Please confirm ticker, period, capital, and concrete entry/exit rules."], "raw": str(e)}

        text = resp.strip()
        implementable = False
        clarifications = []
        for line in text.splitlines():
            up = line.upper().strip()
            if up.startswith("IMPLEMENTABLE:"):
                if "YES" in up:
                    implementable = True
                break
        if not implementable:
            lines = text.splitlines()
            start = False
            for ln in lines:
                if start:
                    s = ln.strip()
                    if not s:
                        break
                    if s.startswith(('-', 'â€¢', '*')) or (len(s) > 1 and s[0].isdigit()):
                        clarifications.append(s.lstrip('-â€¢* ').strip())
                        if len(clarifications) >= 5:
                            break
                    else:
                        break
                elif ln.upper().startswith("CLARIFICATIONS:"):
                    start = True

        return {"implementable": implementable, "clarifications": clarifications, "raw": text}
    
    def _execute_backtest(self, code: str) -> dict:
        """Execute the backtest code."""
        # Execute code in sandbox and return raw result
        return self.sandbox.run(code)
    
    def _handle_code_error(self, test_result: dict, attempt: int) -> str:
        """Handle code validation errors."""
        self.last_error = test_result["error"]
        return self._phase2_implementation(attempt + 1)
    
    def _handle_execution_error(self, result: dict, attempt: int) -> str:
        """Handle execution errors."""
        self.last_error = result["error"]
        return self._phase2_implementation(attempt + 1)
    
    def _critique_results(self, result: dict) -> dict:
        """Critique the backtest results."""
        critique_prompt = f"""Evaluate this backtest result:

REQUIREMENTS:
{self._format_requirements()}

CODE:
{self.code}

RESULTS:
{result['output']}

EVALUATION:
âœ“ Code executed without errors
âœ“ Shows backtest results (Return %, Equity Final, etc.)
âœ“ Uses correct ticker, period, capital
âœ“ Implements the requested strategy

DECISION: [PROCEED or RETRY]

If results are shown and requirements met, say PROCEED."""

        try:
            critique = self.code_llm.ask(critique_prompt)
            proceed = "PROCEED" in critique.upper()
            return {"proceed": proceed, "critique": critique}
        except Exception as e:
            return {"proceed": False, "critique": f"Critique error: {e}"}
    
    def _phase3_reporting(self) -> str:
        """Phase 3: Plan, write, refine report."""
        # Try to extract structured outputs from results
        trades_csv = None
        equity_csv = None
        summary_json = None
        if isinstance(self.results, str):
            text = self.results
            if "SUMMARY_JSON" in text:
                try:
                    summary_json = text.split("SUMMARY_JSON", 1)[1].strip().splitlines()[0]
                except Exception:
                    pass
            if "TRADES_CSV" in text:
                try:
                    trades_csv = text.split("TRADES_CSV", 1)[1].strip()
                    # Keep until next marker if present
                    if "EQUITY_CSV" in trades_csv:
                        trades_csv = trades_csv.split("EQUITY_CSV", 1)[0].strip()
                except Exception:
                    pass
            if "EQUITY_CSV" in text:
                try:
                    equity_csv = text.split("EQUITY_CSV", 1)[1].strip()
                except Exception:
                    pass

        # Save assets folder
        import os
        from datetime import datetime
        os.makedirs("reports", exist_ok=True)
        ticker_slug = (self.requirements.get('ticker') or 'TICKER').replace('^','').replace('.','_')
        period_slug = (self.requirements.get('period') or 'PERIOD').replace(' ','').replace(':','-')
        run_dir = f"reports/{ticker_slug}_{period_slug}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        os.makedirs(run_dir, exist_ok=True)
        
        # Setup logging for this run
        self.debug_logger, self.agent_logger = setup_run_logging(run_dir)

        # Try generating charts using matplotlib if equity CSV exists
        equity_png = None
        trades_table_md = None
        try:
            import pandas as pd  # type: ignore
            import matplotlib.pyplot as plt  # type: ignore
            if equity_csv:
                from io import StringIO
                eq_df = pd.read_csv(StringIO(equity_csv))
                # Guess equity column name
                ycol = 'Equity' if 'Equity' in eq_df.columns else eq_df.columns[-1]
                x = eq_df.index if 'index' in eq_df.columns else range(len(eq_df))
                plt.figure(figsize=(8,4))
                plt.plot(eq_df[ycol])
                plt.title('Equity Curve')
                plt.grid(True, alpha=0.3)
                equity_png = os.path.join(run_dir, 'equity.png')
                plt.tight_layout()
                plt.savefig(equity_png, dpi=150)
                plt.close()
            if trades_csv:
                from io import StringIO
                tr_df = pd.read_csv(StringIO(trades_csv))
                # Build a compact markdown table of first 20 trades
                cols = [c for c in tr_df.columns][:6]
                head = tr_df[cols].head(20)
                trades_table_md = "| " + " | ".join(cols) + " |\n" + "|" + "---|"*len(cols) + "\n"
                for _, row in head.iterrows():
                    trades_table_md += "| " + " | ".join(str(row[c]) for c in cols) + " |\n"
        except Exception:
            pass
        # Plan
        plan_prompt = f"""Plan a backtest report structure:

Results:
{self.results}

Code:
{self.code}

Create outline with sections:
1. Summary
2. Strategy
3. Results
4. Insights
5. Code"""

        plan = self.llm.ask(plan_prompt)
        
        # Write
        write_prompt = f"""Write a professional backtest report:

Plan:
{plan}

Results:
{self.results}

Code:
{self.code}

Write in markdown format:"""

        draft = self.llm.ask(write_prompt)
        
        # Localize summary header if requested
        lang = (self.requirements.get('lang') or 'en').lower()
        if lang.startswith('hi'):
            summary_title = 'à¤¸à¤¾à¤°à¤¾à¤‚à¤¶'
        elif lang.startswith('gu'):
            summary_title = 'àª¸àª¾àª°àª¾àª‚àª¶'
        else:
            summary_title = 'Summary'

        # Compute TL;DR via LLM and inject at top of report; if summary_json exists, prioritize its fields
        if summary_json:
            try:
                import json as _json
                sj = _json.loads(summary_json)
                tldr_line = (
                    f"Strategy: {sj.get('strategy','')} Â· End: {sj.get('end','')} "
                    f"Â· Initial: {sj.get('initial','')} "
                    f"Â· Equity: {sj.get('equity_final','')} "
                    f"Â· Portfolio: {sj.get('portfolio_final','')}"
                )
            except Exception:
                tldr_line = self._llm_tldr(self.results if isinstance(self.results, str) else str(self.results))
        else:
            tldr_line = self._llm_tldr(self.results if isinstance(self.results, str) else str(self.results))
        final_md = f"# {summary_title}\n\n**{tldr_line}**\n\n" + draft
        if trades_table_md:
            final_md += "\n\n## Trades (first 20)\n\n" + trades_table_md
        if equity_png:
            final_md += f"\n\n## Equity Curve\n\n![]({os.path.basename(equity_png)})\n"

        # Save markdown and assets into run directory
        md_path = os.path.join(run_dir, 'report.md')
        with open(md_path, 'w') as f:
            f.write(final_md)
        
        # Save strategy.py (generated code)
        strategy_path = os.path.join(run_dir, 'strategy.py')
        with open(strategy_path, 'w') as f:
            f.write(f"# Generated by NLBT on {datetime.now()}\n")
            f.write(f"# {self._format_requirements()}\n\n")
            f.write(self.code)
        
        # Save agent.log (full context for LLM)
        if self.agent_logger:
            # Metadata
            self.agent_logger.info("=== METADATA ===")
            self.agent_logger.info(f"timestamp: {datetime.now()}")
            self.agent_logger.info(f"run_dir: {run_dir}")
            try:
                import subprocess
                git_sha = subprocess.check_output(['git', 'rev-parse', 'HEAD'], text=True).strip()
                self.agent_logger.info(f"git_sha: {git_sha}")
            except:
                pass
            self.agent_logger.info("")
            
            # Codebase snapshot
            self.agent_logger.info("=== CODEBASE ===")
            base_dir = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
            for pattern in ["src/**/*.py", "*.toml", "README.md"]:
                for file_path in glob.glob(os.path.join(base_dir, pattern), recursive=True):
                    rel_path = os.path.relpath(file_path, base_dir)
                    self.agent_logger.info(f"--- {rel_path} ---")
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            self.agent_logger.info(f.read())
                    except:
                        self.agent_logger.info("[Could not read file]")
                    self.agent_logger.info("")
            
            # Conversation history
            self.agent_logger.info("=== CONVERSATION ===")
            self.agent_logger.info("\n".join(self.history))
            self.agent_logger.info("")
            
            # Generated code
            self.agent_logger.info("=== GENERATED CODE ===")
            self.agent_logger.info(self.code)
            self.agent_logger.info("")
            
            # Backtest output
            self.agent_logger.info("=== BACKTEST OUTPUT ===")
            self.agent_logger.info(self.results)
            self.agent_logger.info("")

        # Convert markdown to PDF
        try:
            # Try using pandoc first (best quality)
            import subprocess
            pdf_path = os.path.join(run_dir, 'report.pdf')
            result = subprocess.run([
                'pandoc', md_path, '-o', pdf_path,
                '--pdf-engine=xelatex',
                '--variable', 'geometry:margin=1in'
            ], capture_output=True, text=True, timeout=30)
            
            if result.returncode != 0:
                raise Exception(f"Pandoc failed: {result.stderr}")
                
        except (FileNotFoundError, subprocess.TimeoutExpired, Exception):
            # Fallback: Try weasyprint
            try:
                import weasyprint
                from markdown import markdown
                
                # Convert markdown to HTML first
                with open(md_path, 'r') as f:
                    md_content = f.read()
                
                html_content = f"""
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="UTF-8">
                    <style>
                        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
                              line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }}
                        h1 {{ color: #2c3e50; border-bottom: 2px solid #3498db; }}
                        h2 {{ color: #34495e; margin-top: 30px; }}
                        table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
                        th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                        th {{ background-color: #f2f2f2; }}
                        code {{ background-color: #f8f9fa; padding: 2px 4px; border-radius: 3px; }}
                        pre {{ background-color: #f8f9fa; padding: 15px; border-radius: 5px; overflow-x: auto; }}
                    </style>
                </head>
                <body>
                {markdown(md_content, extensions=['tables', 'fenced_code'])}
                </body>
                </html>
                """
                
                pdf_path = os.path.join(run_dir, 'report.pdf')
                weasyprint.HTML(string=html_content).write_pdf(pdf_path)
                
            except ImportError:
                # Final fallback: Simple matplotlib PDF (current implementation)
                import matplotlib.pyplot as plt
                from matplotlib.backends.backend_pdf import PdfPages
                
                pdf_path = os.path.join(run_dir, 'report.pdf')
                with PdfPages(pdf_path) as pdf:
                    # Page 1: Title and summary
                    plt.figure(figsize=(8.27, 11.69))
                    plt.axis('off')
                    plt.text(0.5, 0.95, 'NLBT Backtest Report', ha='center', va='top', fontsize=18, weight='bold')
                    
                    # Add the report content as text (first 2000 chars)
                    with open(md_path, 'r') as f:
                        content = f.read()[:2000] + "..." if len(f.read()) > 2000 else f.read()
                    
                    plt.text(0.05, 0.85, content, ha='left', va='top', fontsize=8, 
                            family='monospace', wrap=True)
                    pdf.savefig()
                    plt.close()
        
        self.phase = "complete"
        return f"""ðŸŽ‰ COMPLETE! All 3 phases finished successfully.

ðŸ“„ REPORT FOLDER: {run_dir}
â€¢ User report: report.md, report.pdf
â€¢ Developer trace: debug.log, strategy.py
â€¢ Agent context: agent.log

ðŸ“ˆ WHAT YOU GOT:
â€¢ Complete backtest analysis with performance metrics
â€¢ Strategy insights and recommendations  
â€¢ Full Python code for reproducibility
â€¢ Professional markdown report ready to share
â€¢ Debug logs and full context for iteration

ðŸ’¡ NEXT STEPS:
â€¢ Check the report: {md_path}
â€¢ Try another strategy with different parameters
â€¢ Ask me to explain any results you don't understand

âœ¨ Thanks for using the Reflection Backtesting Assistant!"""

    def _llm_tldr(self, results_text: str) -> str:
        """Produce a single-line summary: strategy, end date, cash, equity, portfolio."""
        strategy = (self.requirements.get('strategy') or '').strip()
        capital = (self.requirements.get('capital') or '').strip()
        prompt = (
            "You will receive: strategy text, initial capital, and raw backtest stats.\n"
            "Output ONE line only, exactly in this format (no extra words):\n"
            "Strategy: <STRATEGY> Â· End: <YYYY-MM-DD> Â· Initial: <INITIAL> Â· Equity: <EQUITY> Â· Portfolio: <PORTFOLIO>\n"
            "Rules:\n"
            "- STRATEGY: use the given strategy text as-is (shorten only if extremely long).\n"
            "- INITIAL: echo the provided initial capital (keep currency symbol/commas if present).\n"
            "- End: extract from stats (field 'End' or similar date). Use YYYY-MM-DD.\n"
            "- Equity and Portfolio: use the ending equity from stats (e.g., 'Equity Final [$]').\n"
            "- If multiple numeric formats appear, choose the clearest currency-labelled value.\n"
            "- No newlines, no explanations, one single line.\n\n"
            f"STRATEGY:\n{strategy}\n\n"
            f"CAPITAL:\n{capital}\n\n"
            f"STATS:\n{results_text}\n\n"
            "ONE-LINE OUTPUT:"
        )
        try:
            line = self.llm.ask(prompt).splitlines()[0].strip()
            return line if line else "Summary unavailable"
        except Exception:
            return "Summary unavailable"
    
    def _get_history(self) -> str:
        """Get recent conversation with better context."""
        if not self.history:
            return "No previous conversation."
        
        # Get last 6 exchanges (3 back-and-forth)
        recent = self.history[-6:]
        
        # Format nicely and include any requirements we've gathered
        formatted = "\n".join(recent)
        
        if self.requirements:
            formatted += f"\n\nCURRENT REQUIREMENTS GATHERED:\n"
            for key, value in self.requirements.items():
                formatted += f"- {key.title()}: {value}\n"
        
        return formatted
    
    def _update_requirements_from_conversation(self, user_input: str):
        """Extract requirements from natural conversation."""
        user_lower = user_input.lower()
        
        # Extract ticker symbols with improved logic
        import re

        # Look for ticker patterns in the entire input (more flexible)
        ticker_patterns = [
            r'\b([A-Z]{2,5})\b',  # Standard ticker format
            r'ticker[:\s]+([A-Z]{2,5})',  # Explicit ticker mentions
            r'stock[:\s]+([A-Z]{2,5})',   # Stock mentions
        ]

        for pattern in ticker_patterns:
            matches = re.findall(pattern, user_input)  # Find all, no IGNORECASE
            for potential_ticker in matches:
                potential_ticker = potential_ticker.upper()
                # Validate it's a common ticker
                if potential_ticker in ["AAPL", "MSFT", "GOOGL", "TSLA", "NVDA", "SPY", "QQQ", "AMZN", "META", "NFLX"] and not self.requirements.get("ticker"):
                    self.requirements["ticker"] = potential_ticker
                    break
            if self.requirements.get("ticker"):
                break

        # Also check for company names and map to tickers (incl. India aliases)
        company_to_ticker = {
            "amazon": "AMZN",
            "apple": "AAPL",
            "microsoft": "MSFT",
            "tesla": "TSLA",
            "nvidia": "NVDA",
            "google": "GOOGL",
            "meta": "META",
            "netflix": "NFLX",
            "spy": "SPY",
            "qqq": "QQQ",
            # India
            "reliance": "RELIANCE.NS",
            "tcs": "TCS.NS",
            "hdfcbank": "HDFCBANK.NS",
            "icicibank": "ICICIBANK.NS",
            "infosys": "INFY.NS",
            "nifty": "^NSEI",
            "banknifty": "^NSEBANK"
        }

        for company, ticker in company_to_ticker.items():
            if company in user_lower and not self.requirements.get("ticker"):
                self.requirements["ticker"] = ticker
                break
        
        # Extract periods
        if "2024" in user_input and not self.requirements.get("period"):
            self.requirements["period"] = "2024"
        elif "2023" in user_input and not self.requirements.get("period"):
            self.requirements["period"] = "2023"  
        elif re.search(r'20\d{2}\s*to\s*20\d{2}', user_input) and not self.requirements.get("period"):
            period_match = re.search(r'(20\d{2}\s*to\s*20\d{2})', user_input)
            if period_match:
                self.requirements["period"] = period_match.group(1)
        
        # Extract capital amounts: support $ and â‚¹ / INR and Indian commas
        if not self.requirements.get("capital"):
            import re as _re
            cap_num = None
            m_usd = _re.search(r'\$\s*([0-9,]+(?:K|k)?)', user_input)
            m_inr = _re.search(r'(?:â‚¹|INR)\s*([0-9,]+)', user_input, _re.IGNORECASE)
            if m_usd:
                cap = m_usd.group(1).replace(',', '')
                if cap.lower().endswith('k'):
                    cap_num = int(float(cap[:-1]) * 1000)
                else:
                    cap_num = int(cap)
                self.requirements["capital"] = f"${cap_num}"
            elif m_inr:
                cap = m_inr.group(1).replace(',', '')
                cap_num = int(cap)
                self.requirements["capital"] = f"â‚¹{cap_num}"
        
        # Extract strategy - look for complete trading descriptions
        strategy_patterns = [
            r'buy.*?stop.*?loss.*?take.*?profit',  # Buy with stop loss and take profit
            r'buy.*?open',  # Buy at open
            r'sell.*?close',  # Sell at close
            r'moving.*?average',  # Moving average strategies
            r'rsi.*?buy.*?sell',  # RSI strategies
            r'ema.*?buy.*?sell',  # EMA strategies
            r'sma.*?buy.*?sell',  # SMA strategies
        ]

        # Also check for any mention of trading rules
        if any(word in user_lower for word in ["buy", "sell", "stop loss", "take profit", "entry", "exit", "hold"]):
            # Extract the full strategy description if it contains trading terms
            words = user_input.split()
            if len(words) >= 2:  # At least 2 words (e.g., "buy hold")
                # Find the FIRST part with trading terms (could be at the beginning)
                strategy_start = -1
                for i, word in enumerate(words):
                    if word.lower() in ["buy", "sell", "enter", "exit", "stop", "take", "profit", "test", "trading", "hold"]:
                        strategy_start = i
                        break

                if strategy_start != -1:
                    strategy_text = ' '.join(words[strategy_start:])
                    if len(strategy_text) >= 5 and not self.requirements.get("strategy"):  # At least 5 chars
                        self.requirements["strategy"] = strategy_text.strip()
                else:
                    # If no clear start found, check if the whole input looks like a strategy
                    if len(user_input) > 5 and not self.requirements.get("strategy"):
                        self.requirements["strategy"] = user_input.strip()
            elif len(words) == 1 and len(user_input) >= 5:
                # Single word that's a strategy keyword
                if any(kw in user_lower for kw in ["buy", "sell", "hold"]):
                    self.requirements["strategy"] = user_input.strip()

        # Special case: if we have most requirements but strategy seems incomplete, use full input
        if (self.requirements.get("ticker") and self.requirements.get("period") and
            self.requirements.get("capital") and not self.requirements.get("strategy")):
            if len(user_input) > 20:
                self.requirements["strategy"] = user_input.strip()

        # Legacy keyword extraction for backup
        strategy_keywords = []
        if "buy" in user_lower and "monday" in user_lower:
            strategy_keywords.append("buy on Monday")
        if "rsi" in user_lower:
            strategy_keywords.append("RSI strategy")
        if "moving average" in user_lower or "ma" in user_lower:
            strategy_keywords.append("moving average")
        if "bollinger" in user_lower:
            strategy_keywords.append("Bollinger Bands")

        if strategy_keywords and not self.requirements.get("strategy"):
            self.requirements["strategy"] = ", ".join(strategy_keywords)
    
    def _extract_requirements(self, response: str):
        """Parse requirements from LLM response."""
        lines = response.split("\n")
        for line in lines:
            line = line.strip()
            if "TICKER:" in line and "MISSING" not in line and "?" not in line:
                self.requirements["ticker"] = line.split("TICKER:")[1].strip()
            elif "PERIOD:" in line and "MISSING" not in line and "?" not in line:
                self.requirements["period"] = line.split("PERIOD:")[1].strip()
            elif "CAPITAL:" in line and "MISSING" not in line and "?" not in line:
                self.requirements["capital"] = line.split("CAPITAL:")[1].strip()
            elif "STRATEGY:" in line and "MISSING" not in line and "?" not in line:
                self.requirements["strategy"] = line.split("STRATEGY:")[1].strip()
    
    def _format_requirements(self) -> str:
        """Format current requirements for display with better context."""
        if not self.requirements:
            return "No requirements gathered yet."
        
        formatted = []
        for key, value in self.requirements.items():
            formatted.append(f"- {key.title()}: {value}")
        return "\n".join(formatted)



--- src/nlbt/__init__.py ---
"""Natural Language Backtesting - Reflection Pattern."""

__version__ = "0.2.0"


--- src/nlbt/llm.py ---
"""Minimal LLM client using llm CLI."""

import subprocess
import os
from typing import List, Dict

# Auto-load .env if available (non-fatal if missing)
try:
    from dotenv import load_dotenv  # type: ignore
    load_dotenv()
except Exception:
    pass


class LLM:
    """Simple LLM wrapper."""
    
    def __init__(self, model: str = None):
        self.model = model or os.getenv("LLM_MODEL") or self._get_default()
    
    def _get_default(self) -> str:
        """Get default model from llm CLI."""
        try:
            result = subprocess.run(
                ["llm", "models", "default"],
                capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0 and result.stdout.strip():
                return result.stdout.strip()
        except:
            pass
        return "gpt-4o-mini"
    
    def ask(self, prompt: str) -> str:
        """Ask LLM a question, get response."""
        result = subprocess.run(
            ["llm", "-m", self.model],
            input=prompt,
            capture_output=True,
            text=True,
            timeout=120
        )
        
        if result.returncode != 0:
            raise RuntimeError(f"LLM failed: {result.stderr}")
        
        return result.stdout.strip()



--- src/nlbt/sandbox.py ---
"""Minimal sandbox for code execution."""

import io
import sys
from contextlib import redirect_stdout, redirect_stderr


class Sandbox:
    """Execute code safely."""
    
    def run(self, code: str) -> dict:
        """Execute Python code, return results."""
        stdout_capture = io.StringIO()
        stderr_capture = io.StringIO()
        
        # Build safe globals with required libraries
        safe_globals = self._get_globals()
        
        try:
            with redirect_stdout(stdout_capture), redirect_stderr(stderr_capture):
                exec(code, safe_globals)
            
            return {
                "success": True,
                "output": stdout_capture.getvalue(),
                "error": None
            }
        except Exception as e:
            return {
                "success": False,
                "output": stdout_capture.getvalue(),
                "error": f"{type(e).__name__}: {str(e)}\n{stderr_capture.getvalue()}"
            }
    
    def _get_globals(self) -> dict:
        """Get safe global namespace with libraries."""
        import importlib
        
        globals_dict = {"__builtins__": __builtins__}
        
        # Allow these libraries
        for lib in ["pandas", "numpy", "backtesting", "ta"]:
            try:
                globals_dict[lib] = importlib.import_module(lib)
            except ImportError:
                pass
        
        # Add helper function
        globals_dict["get_ohlcv_data"] = self._get_data
        
        # Intentionally no indicator fallbacks â€” coding agent must use libraries (ta, etc.)
        
        return globals_dict
    
    def _get_data(self, ticker: str, start: str, end: str):
        """Helper to fetch OHLCV data for backtesting.py library."""
        import yfinance as yf
        import pandas as pd
        
        # Download data
        data = yf.download(ticker, start=start, end=end, progress=False)
        
        # Remove timezone if present
        if data.index.tz:
            data = data.tz_localize(None)
        
        # Handle MultiIndex columns (yfinance returns (column_name, ticker))
        # We need to keep just the column names: Open, High, Low, Close, Volume
        if isinstance(data.columns, pd.MultiIndex):
            # Drop the ticker level (level 1), keep column names (level 0)
            data.columns = data.columns.droplevel(1)
        
        return data



--- src/nlbt/cli.py ---
"""Minimal CLI for reflection backtesting."""

import sys
from .reflection import ReflectionEngine
from datetime import datetime
import os
from rich.console import Console
from rich.panel import Panel


def main():
    """Run the backtesting assistant."""
    model = sys.argv[1] if len(sys.argv) > 1 else None
    engine = ReflectionEngine(model)
    console = Console()
    header = (
        f"[bold cyan]ðŸ§  Backtesting Assistant (WIP)[/bold cyan]\n"
        f"[dim]Chat model:[/dim] {engine.llm.model}\n"
        f"[dim]Code model:[/dim] {engine.code_llm.model} (strong model for implementation)\n\n"
        "[bold]ðŸ“‹ How it works:[/bold]\n"
        "  â€¢ Phase 1 (ðŸ” Understanding): Ask until info is complete\n"
        "  â€¢ Phase 2 (âš™ï¸ Implementation): Generate, test, refine code\n"
        "  â€¢ Phase 3 (ðŸ“Š Reporting): Produce a professional report\n\n"
        "[bold]âš ï¸ Current limitations:[/bold]\n"
        "  â€¢ Single ticker strategies work best (multi-asset may fail)\n"
        "  â€¢ Uses Yahoo Finance data (US stocks, ETFs, crypto with -USD suffix)\n"
        "  â€¢ Max 3 code generation attempts per strategy\n"
        "  â€¢ Requires LLM API access and credits\n"
        "  â€¢ Generated code runs locally (trusted environment only)\n\n"
        "[bold]ðŸ’¬ You can:[/bold]\n"
        "  â€¢ Describe your strategy (e.g. 'Buy SPY when RSI < 30')\n"
        "  â€¢ Type 'info' for current phase and requirements\n"
        "  â€¢ Type 'debug' for internal state\n"
        "  â€¢ Type 'exit' to quit\n\n"
        "ðŸš€ Ready! Describe your single-ticker trading strategy..."
    )
    console.print(Panel.fit(header, title="NLBT", border_style="cyan"))
    
    while True:
        try:
            user_input = input("ðŸ’­ You: ").strip()

            # Skip completely empty inputs or just prompts
            if not user_input:
                continue

            # Skip inputs that are just whitespace or newlines
            if len(user_input.replace(' ', '').replace('\n', '').replace('\t', '')) == 0:
                continue

            # Skip repeated empty prompts (defensive programming)
            if user_input == "ðŸ’­ You:" or user_input.startswith("ðŸ’­ You:"):
                continue
            
            if user_input.lower() in ["exit", "quit", "bye"]:
                print("\nðŸ‘‹ Goodbye!")
                break
            
            if user_input.lower() in ["lucky", "i'm feeling lucky", "feeling lucky", "demo"]:
                # Submit a default NL prompt through the same agent path; no auto-proceed
                console.print("\n[bold]ðŸŽ² I'm feeling lucky[/bold] â€” using: [dim]Buy and hold AAPL in 2024 with $10,000[/dim]")
                default_prompt = "Buy and hold AAPL in 2024 with $10,000"
                with Console().status("Processing...", spinner="dots"):
                    resp = engine.chat(default_prompt)
                Console().print(f"\nðŸ¤– {resp}\n")
                continue
            
            if user_input.lower() == "info":
                phase_info = {
                    "understanding": "ðŸ” Phase 1 - Gathering requirements and asking clarifying questions",
                    "ready_to_implement": "âœ… Ready to implement - Waiting for your confirmation to proceed",
                    "implementation": "âš™ï¸ Phase 2 - Generating Python code, testing, and refining",
                    "reporting": "ðŸ“Š Phase 3 - Creating professional analysis report",
                    "complete": "âœ… All phases complete - ready for new strategy"
                }
                
                print(f"\nðŸ“ Current Phase: {phase_info.get(engine.phase, engine.phase)}")
                
                if engine.requirements:
                    print(f"\nðŸ“‹ Requirements Gathered:")
                    for key, value in engine.requirements.items():
                        print(f"  â€¢ {key.title()}: {value}")
                
                if engine.phase == "understanding":
                    print(f"\nðŸ’¬ What you can do:")
                    print(f"  â€¢ Answer my questions to provide missing info")
                    print(f"  â€¢ Say 'actually...' or 'change...' to modify requirements")
                    print(f"  â€¢ Provide more details about your strategy")
                elif engine.phase == "ready_to_implement":
                    print(f"\nðŸ’¬ What you can do:")
                    print(f"  â€¢ Type 'yes', 'go', or 'proceed' to start implementation")
                    print(f"  â€¢ Type 'explain' for detailed implementation approach")
                    print(f"  â€¢ Type 'change [requirement]' to modify anything")
                elif engine.phase == "implementation":
                    print(f"\nðŸ’¬ What you can do:")
                    print(f"  â€¢ Wait for code generation to complete")
                    print(f"  â€¢ Type 'debug' to see current progress")
                    print(f"  â€¢ Say 'change...' to modify requirements (restarts Phase 1)")
                elif engine.phase == "reporting":
                    print(f"\nðŸ’¬ What you can do:")
                    print(f"  â€¢ Wait for report generation to complete")
                    print(f"  â€¢ The report will be saved automatically")
                else:
                    print(f"\nðŸ’¬ What you can do:")
                    print(f"  â€¢ Start a new strategy by describing it")
                    print(f"  â€¢ Ask questions about the previous results")
                
                print()
                continue
            
            if user_input.lower() == "debug":
                console.print("\n[bold]ðŸ› Debug Info:[/bold]")
                console.print(f"Phase: {engine.phase}")
                console.print(f"History length: {len(engine.history)}")
                if engine.history:
                    console.print("Last 3 history items:")
                    for item in engine.history[-3:]:
                        console.print(f"  {item}")
                if engine.requirements:
                    console.print(f"Requirements: {engine.requirements}")
                if engine.code:
                    console.print(f"\nðŸ“ Last Code Generated:\n{engine.code[:500]}...")
                if engine.last_error:
                    console.print(f"\nâŒ Last Error:\n{engine.last_error}")
                if engine.results:
                    console.print(f"\nâœ… Last Results:\n{engine.results[:300]}...")
                if getattr(engine, 'last_validation', None) is not None:
                    console.print(f"\nðŸ”Ž Last Validation:\n{engine.last_validation}")
                console.print()
                continue
            
            # Process
            phase_emoji = {
                "understanding": "ðŸ”",
                "ready_to_implement": "âœ…",
                "implementation": "âš™ï¸", 
                "reporting": "ðŸ“Š",
                "complete": "âœ…"
            }
            
            with Console().status(f"{phase_emoji.get(engine.phase, 'ðŸ¤”')} Processing...", spinner="dots"):
                response = engine.chat(user_input)
            Console().print(f"\nðŸ¤– {response}\n")

            # Check if conversation is complete and handle accordingly
            if engine.phase == "complete":
                print("ðŸ’¡ Conversation completed! Ready for new strategy.\n")
            
        except KeyboardInterrupt:
            print("\n\nUse 'exit' to quit")
            continue
        except EOFError:
            break
        except Exception as e:
            print(f"\nâŒ Error: {e}\n")


if __name__ == "__main__":
    main()



--- src/nlbt/llm/client.py ---
"""LLM CLI wrapper for PocketFlow integration."""

import json
import subprocess
import sys
from typing import Any, Dict, List, Optional

from dotenv import load_dotenv

load_dotenv()


class LLMClient:
    """Wrapper around `llm` CLI for model access."""
    
    def __init__(self, model: Optional[str] = None):
        """Initialize LLM client.
        
        Args:
            model: Model to use. If None, uses LLM_MODEL from .env
        """
        self.model = model or self._get_default_model()
    
    def _get_default_model(self) -> str:
        """Get default model from environment or llm CLI default."""
        import os
        import subprocess
        
        # First check env var
        env_model = os.getenv("LLM_MODEL")
        if env_model:
            return env_model
        
        # Fall back to llm CLI default
        try:
            result = subprocess.run(
                ["llm", "models", "default"],
                capture_output=True,
                text=True,
                timeout=5
            )
            if result.returncode == 0 and result.stdout.strip():
                return result.stdout.strip()
        except:
            pass
        
        # Last resort: use a common model
        return "gpt-4o-mini"
    
    def chat(self, messages: List[Dict[str, str]], tools: Optional[List[Dict]] = None) -> Dict[str, Any]:
        """Send messages to LLM and get response.
        
        Args:
            messages: List of message dicts with 'role' and 'content'
            tools: Optional list of tool definitions for function calling
            
        Returns:
            Dict with 'type' ('text' or 'tool_call') and response content
        """
        # Build complete prompt from messages
        prompt_parts = []
        for msg in messages:
            if msg['role'] == 'system':
                prompt_parts.append(f"System: {msg['content']}")
            elif msg['role'] == 'user':
                prompt_parts.append(f"User: {msg['content']}")
            elif msg['role'] == 'assistant':
                prompt_parts.append(f"Assistant: {msg['content']}")
        
        full_prompt = "\n\n".join(prompt_parts)
        
        # Build llm CLI command
        cmd = [
            "llm",
            "-m", self.model
        ]
        
        try:
            # Run llm CLI
            process = subprocess.run(
                cmd,
                input=full_prompt,
                text=True,
                capture_output=True,
                timeout=120  # 2 minute timeout for LLM calls
            )
            
            if process.returncode != 0:
                raise RuntimeError(f"llm CLI failed: {process.stderr}")
            
            # Parse response
            response_text = process.stdout.strip()
            if not response_text:
                raise RuntimeError("Empty response from llm CLI")
            
            return {"type": "text", "content": response_text}
                
        except subprocess.TimeoutExpired:
            raise RuntimeError("LLM call timed out")
        except Exception as e:
            raise RuntimeError(f"LLM call failed: {e}")
    
    def _build_system_prompt(self, tools: Optional[List[Dict]] = None) -> str:
        """Build system prompt with tool definitions."""
        base_prompt = """You are a financial backtesting assistant. You help users backtest trading strategies by asking clarifying questions, writing Python code, and executing backtests."""
        
        if tools:
            tools_desc = "\n".join([
                f"- {tool['name']}: {tool.get('description', 'No description')}"
                for tool in tools
            ])
            base_prompt += f"\n\nYou have access to these tools:\n{tools_desc}"
        
        return base_prompt


--- pyproject.toml ---
[build-system]
requires = ["setuptools>=45", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "nlbt"
version = "0.2.0"
description = "Natural Language Backtesting - Reflection Pattern"
requires-python = ">=3.8"
dependencies = [
    "pandas",
    "numpy",
    "yfinance",
    "backtesting",
    "ta",
    "llm",
    "python-dotenv",
    "rich",
    "matplotlib",
    "markdown",
    "weasyprint",
]

[project.scripts]
nlbt = "nlbt.cli:main"



--- README.md ---
# NLBT â€” Natural Language Backtesting

> **Turn plain English into professional backtesting reports in minutes.**  
> Describe your trading strategy in natural language. Get Python code, backtest results, and professional reports. No coding required.

---

## ðŸš€ Quick Start

```bash
# 1. Install
git clone https://github.com/yourusername/nlbt && cd nlbt
pip install -e .

# 2. Configure LLM
llm keys set openrouter
llm models default openrouter/anthropic/claude-3.5-sonnet

# 3. Run
nlbt
```

**Try it**: Type `"Buy and hold AAPL in 2024 with $10,000"` and press enter.

---

## âœ¨ Key Benefits

| Feature | Benefit |
|---------|---------|
| ðŸ’¬ **Natural Language** | Describe strategies in plain English - no coding needed |
| ðŸ¤– **AI-Powered** | Uses Claude 3.5 Sonnet for robust code generation |
| âš¡ **Fast** | Get results in 2-3 minutes, costs <$0.10 per strategy |
| ðŸ”„ **Self-Correcting** | Auto-retries up to 3 times with error recovery |
| ðŸ“Š **Professional Reports** | Markdown + PDF with metrics, charts, and full code |
| ðŸ”§ **Three-Tier Output** | User reports, developer code, agent checkpoints |

---

## ðŸ“¥ What You Get

### Input â†’ Output

**You type:**
```
"Buy and hold AAPL in 2024 with $10000"
```

**You get** (in `reports/AAPL_2024_<timestamp>/`):

> ðŸ“ **See actual example**: [`reports/EXAMPLE_AAPL_2024/`](reports/EXAMPLE_AAPL_2024/)  
> ðŸ“„ **View report**: [`report.md`](reports/EXAMPLE_AAPL_2024/report.md) | [`report.pdf`](reports/EXAMPLE_AAPL_2024/report.pdf)  
> ðŸ’» **View code**: [`strategy.py`](reports/EXAMPLE_AAPL_2024/strategy.py)

#### ðŸ“Š Professional Report (`report.md` / `report.pdf`)
```markdown
# AAPL 2024 Backtest Report

## Summary
- Test Period: 2024-01-02 to 2024-12-30 (363 days)
- Initial Capital: $10,000
- Final Equity: $13,887.79
- Absolute Return: $3,887.79
- Percentage Return: 38.88%

## Performance Metrics
- ðŸ“ˆ Return: 38.88%
- ðŸ“Š Sharpe Ratio: 1.25
- ðŸ“‰ Max Drawdown: -15.26%
- ðŸ’¹ Sortino Ratio: 2.76
- ðŸ“ Calmar Ratio: 2.56
- ðŸŽ¯ Buy & Hold Return: 36.52%
- ðŸ“Š Annualized Volatility: 31.29%
- ðŸ”¢ Alpha: 2.74% | Beta: 0.99

## Strategy
- Strategy Name: MyStrategy
- Description: Simple buy and hold - enter position when no current positions held
- Entry Criteria: Buy when not in position
- Exit Criteria: Hold until end of period

## Code
[Full Python implementation included]
[Detailed analysis and insights]
[Recommendations for future testing]
```

#### ðŸ’» Executable Code (`strategy.py`)
```python
# Generated by NLBT
# - Ticker: AAPL
# - Period: 2024
# - Capital: $10000
# - Strategy: Buy and hold AAPL in 2024 with $10000

from backtesting import Backtest, Strategy

data = get_ohlcv_data('AAPL', '2024-01-01', '2024-12-31')

class MyStrategy(Strategy):
    def init(self):
        pass
    
    def next(self):
        if not self.position:
            self.buy()

bt = Backtest(data, MyStrategy, cash=10000)
stats = bt.run()
print(stats)

# Emit structured artifacts for reporting
import json
try:
    import pandas as pd
    print("TRADES_TABLE")
    print(stats._trades.head(20).to_markdown(index=False))
except Exception:
    pass
```

#### ðŸ” Debug & Agent Logs
- `debug.log` - Execution trace for troubleshooting
- `agent.log` - Full LLM context for iteration (~6-8K words)

---

## âš ï¸ Important Notes

- **Safety**: This tool runs AI-generated Python code locally. Use in trusted environments only.
- **Status**: Functional for single-ticker strategies. APIs may change without notice.
- **Limitations**: Multi-asset portfolios not yet supported. Works best with clear strategy descriptions.

## Requirements
- Python 3.8+
- OpenRouter account (recommended) or OpenAI/Anthropic
- 5 minutes for setup

## Install & Setup

### 1. Clone and install everything
```bash
git clone https://github.com/yourusername/nlbt
cd nlbt
pip install -e .
```
*This installs all dependencies including `llm` CLI, `backtesting`, `ta`, and more*

### 2. Set up OpenRouter (recommended)
**Why OpenRouter?** Cost control, multiple models, spending limits

1. **Create account**: Go to https://openrouter.ai/
2. **Get API key**: Click "Keys" â†’ "Create Key" 
3. **Add credits**: Add $5-10 (you'll use <$1 for examples)
4. **Set spending limit**: Optional but recommended
5. **Configure locally**:
```bash
llm keys set openrouter
# Paste your API key when prompted

llm models default openrouter/anthropic/claude-3.5-sonnet
```

### 3. Quick test
```bash
nlbt
```
**Try**: "Buy and hold AAPL in 2024 with $1000"

**What you should see**:
- Agent asks clarifying questions (if needed)
- Shows "Phase 1 - Understanding" â†’ "Phase 2 - Implementation" â†’ "Phase 3 - Reporting"  
- Saves report to `reports/<TICKER>_<PERIOD>_<TIMESTAMP>/report.md` (+ PDF)
- Takes 2-3 minutes total

---

## ðŸ’¬ Usage

```bash
nlbt                    # Start interactive session
```

**In-chat commands:**
- `info` - Show current phase and requirements
- `debug` - Show internal state  
- `lucky` - Quick demo with AAPL
- `exit` - Quit

---

## ðŸ”„ How It Works

NLBT uses a **3-phase agentic workflow** with automatic error recovery:

### Simple Overview

1. **ðŸ” Understanding** - Chat with AI to gather requirements (ticker, period, capital, strategy)
2. **âš™ï¸ Implementation** - AI generates Python code, tests it, and auto-retries if needed
3. **ðŸ“Š Reporting** - AI creates professional analysis with metrics and insights

### Visual Workflow

<details>
<summary>Click to see detailed architecture diagram</summary>

**Color Key:**
- **Purple** = User actions | **Yellow** = LLM actions | **Green** = System/sandbox
- **Orange** = Decisions | **Teal** = Phase states | **Gray** = Outputs

```mermaid
graph TD
    Start([User describes strategy]) --> P1[Phase 1: Understanding]
    P1 --> Extract[Extract requirements from conversation]
    Extract --> Check{Complete &<br/>implementable?}
    
    Check -->|Missing/unclear| Ask[Ask clarifying questions]
    Ask --> P1
    
    Check -->|Complete & valid| Ready[Ready to Implement]
    Ready --> Present[Present plan to user]
    Present --> Response{User response}
    
    Response -->|Anything else| BackToP1[Return to understanding]
    BackToP1 --> P1
    Response -->|Yes/Go| P2[Phase 2: Implementation]
    
    P2 --> Plan[Plan: LLM creates implementation plan]
    Plan --> Code[Producer: Generate Python code]
    Code --> Test[Test: Validate syntax & imports]
    Test --> Execute[Execute: Run in sandbox]
    Execute --> Critic[Critic: Evaluate results]
    Critic --> Decision{Critic decision}
    
    Decision -->|PASS| P3[Phase 3: Reporting]
    Decision -->|RETRY| Count{Attempt < 3?}
    Count -->|Yes| Plan
    Count -->|No| FailBack[Show error & return to understanding]
    FailBack --> P1
    
    P3 --> ReportPlan[Plan: Structure report]
    ReportPlan --> Write[Write: Generate markdown]
    Write --> Refine[Refine: Polish & save]
    Refine --> Done([Report saved])

    %% Role-based styling
    classDef user fill:#d1c4e9,stroke:#7e57c2,color:#4a148c;
    classDef llm fill:#fff9c4,stroke:#fbc02d,color:#6d4c41;
    classDef system fill:#e8f5e9,stroke:#43a047,color:#1b5e20;
    classDef decision fill:#ffccbc,stroke:#e64a19,color:#bf360c;
    classDef userInput fill:#e1bee7,stroke:#8e24aa,color:#4a148c;
    classDef state fill:#b2dfdb,stroke:#00897b,color:#004d40;
    classDef output fill:#eceff1,stroke:#90a4ae,color:#37474f;

    %% Assign roles
    class Start user;
    class P1,P2,P3,Ready state;
    class Extract,Ask,Plan,Code,Critic,ReportPlan,Write,Refine llm;
    class Test,Execute,Present system;
    class Check,Decision,Count decision;
    class Response userInput;
    class Done output;
    class BackToP1,FailBack system;
```

</details>

### Key Features

- **Smart Confirmation**: Say "yes" to proceed, anything else returns to conversation
- **Auto-Retry**: Up to 3 attempts with error feedback
- **Error Recovery**: After failures, returns to chat with error context
- **Producer-Critic Pattern**: Separate AI for generation and evaluation (reduces bias)

---

## Examples (realistic conversations)

**Simple Buy & Hold**
```bash
ðŸ’­ You: Buy and hold AAPL in 2024 with $10,000

ðŸ¤– Perfect! I have everything needed:
   â€¢ Ticker: AAPL
   â€¢ Period: 2024
   â€¢ Capital: $10,000
   â€¢ Strategy: Buy and hold
   
   Ready to implement? (yes/no/change/explain)

ðŸ’­ You: yes

ðŸ¤– âš™ï¸ Phase 2: Implementation
   [Attempt 1/3] Planning implementation...
   [Attempt 1/3] Generating Python code...
   [Attempt 1/3] Testing code...
   [Attempt 1/3] Executing backtest...
   [Attempt 1/3] Results: Return 38.88%, Sharpe 1.25, Max DD -15.26%
   âœ… Critic: PASS - Proceeding to reporting

ðŸ¤– ðŸ“Š Phase 3: Reporting
   Planning report structure...
   Writing comprehensive analysis...
   âœ… Report saved: reports/AAPL_2024_20241002_123456/report.md
```

**RSI Strategy** 
```bash
ðŸ’­ You: NVDA with RSI: buy when RSI < 30, sell when RSI > 70, 2023, $20K

ðŸ¤– STATUS: READY
   â€¢ Ticker: NVDA
   â€¢ Period: 2023  
   â€¢ Capital: $20,000
   â€¢ Strategy: RSI mean reversion (buy <30, sell >70)
   
   Proceed? (yes/no/change/explain)

ðŸ’­ You: yes

ðŸ¤– [Generates â†’ Tests â†’ âœ“ PASS]
   âœ… Report: reports/NVDA_2023_20241002_143012/report.md
```

**Progressive Disclosure** (provide info gradually)
```bash
ðŸ’­ You: Test a moving average crossover

ðŸ¤– I'll help you backtest a moving average strategy! I need:
   â€¢ Which ticker? (e.g., AAPL, SPY, TSLA)
   â€¢ Time period? (e.g., 2024, 2020-2023)
   â€¢ Initial capital? (e.g., $10,000)
   â€¢ Which MA periods? (e.g., 50/200 day)

ðŸ’­ You: SPY, 2024, $25K

ðŸ¤– Great! Which moving average periods? (e.g., 20/50, 50/200)

ðŸ’­ You: use 50/200 day crossover

ðŸ¤– Perfect! All set. Ready to proceed?

ðŸ’­ You: yes
```

---

## ðŸ”§ Troubleshooting

<details>
<summary>Common Issues & Solutions</summary>

### "Unknown model" error
```bash
llm models list                    # See available models
llm models default [model-name]    # Set default
```

### "LLM failed" or timeout
- Check API key: `llm keys list`
- Check OpenRouter credits/limits
- Try simpler strategy description
- Use `debug` command to see internal state

### "No data found" error  
- Verify ticker symbol (use Yahoo Finance format)
- Ensure date range is in the past
- Try different dates or ticker

### Code execution fails
- Agent will auto-retry up to 3 times
- If still failing, simplify your strategy
- Use `info` to see what requirements were gathered
- Check for typos in ticker/dates

### General debugging
- Use `info` command to see current phase
- Use `debug` command to see conversation history
- Check `reports/` folder for any partial outputs
- Restart with `exit` and try again

</details>

<details>
<summary>Alternative LLM Providers</summary>

**OpenAI**:
```bash
llm keys set openai
llm models default gpt-4o-mini
```

**Anthropic**:
```bash
llm keys set anthropic  
llm models default claude-3-5-sonnet-20241022
```

</details>

## ðŸ¤ Contributing

Contributions welcome! Areas of interest:
- Multi-asset portfolio backtesting
- Additional technical indicators  
- Parameter optimization
- Risk management strategies
- Interactive visualizations

See issues or open a PR!

---

## ðŸ“„ License

GPL-3.0 License. See `LICENSE`.

This is copyleft software - any derivative works must also be open source under GPL-3.0.

---

## ðŸ—ï¸ Technical Details

<details>
<summary>Project Structure</summary>

```
src/nlbt/
â”œâ”€â”€ cli.py              # Interactive CLI with rich formatting
â”œâ”€â”€ reflection.py       # 3-phase reflection engine
â”œâ”€â”€ llm.py              # LLM wrapper using `llm` CLI
â””â”€â”€ sandbox.py          # Safe code execution

reports/                # Generated backtest reports
â”œâ”€â”€ <TICKER>_<PERIOD>_<TIMESTAMP>/
â”‚   â”œâ”€â”€ report.md       # User: Professional report
â”‚   â”œâ”€â”€ report.pdf      # User: PDF version
â”‚   â”œâ”€â”€ strategy.py     # Developer: Executable code
â”‚   â”œâ”€â”€ debug.log       # Developer: Execution trace
â”‚   â””â”€â”€ agent.log       # Agent: Full LLM context
â””â”€â”€ EXAMPLE_*/          # Sample outputs

tests/                  # Unit and integration tests
```

</details>

<details>
<summary>Architecture & Design Patterns</summary>

This project implements several **Agentic Design Patterns**:

- **Reflection Pattern**: 3-phase autonomous workflow with LLM controlling transitions
- **Producer-Critic Pattern**: Separate models for generation and evaluation (avoids confirmation bias)
- **Planning Pattern**: Phase 2 plans before coding; Phase 3 plans before writing
- **Tool Use Pattern**: Sandbox execution, data fetching, indicator calculations
- **Prompt Chaining**: Phase transitions chain prompts with context
- **Error Recovery**: Auto-retry loop (max 3 attempts) with error feedback
- **Checkpoint Pattern**: Three-tier output (user/developer/agent) for reproducibility

See `cursor_chats/Agentic_Design_Patterns_Complete.md` for detailed documentation.

</details>

=== CONVERSATION ===
User: Buy and hold AAPL in 2024 with $10000

=== GENERATED CODE ===
from backtesting import Backtest, Strategy

data = get_ohlcv_data('AAPL', '2024-01-01', '2024-12-31')

class MyStrategy(Strategy):
    def init(self):
        pass
    
    def next(self):
        if not self.position:
            self.buy()

bt = Backtest(data, MyStrategy, cash=10000)
stats = bt.run()
print(stats)

# Emit structured artifacts for reporting
import json
try:
    # Trades preview table
    import pandas as pd
    print("TRADES_TABLE")
    print(stats._trades.head(20).to_markdown(index=False))
except Exception:
    pass

# Full CSVs for optional charts/tables
try:
    import pandas as pd
    print("TRADES_CSV"); print(stats._trades.to_csv(index=False))
    print("EQUITY_CSV"); print(stats._equity_curve.to_csv(index=False))
except Exception:
    pass

# Compact summary for TL;DR
try:
    end_date = str(stats.get('End', '')) or (str(data.index[-1].date()) if hasattr(data, 'index') and len(data.index) else '')
    equity_final = float(stats.get('Equity Final [$]', 0))
    initial_cap = float(10000)
    pnl_abs = equity_final - initial_cap
    pnl_pct = float(stats.get('Return [%]', 0))
    print("SUMMARY_JSON"); print(json.dumps(dict(
        end=end_date,
        initial=initial_cap,
        equity_final=equity_final,
        portfolio_final=equity_final,
        pnl_abs=pnl_abs,
        pnl_pct=pnl_pct
    )))
except Exception:
    pass

=== BACKTEST OUTPUT ===
Start                     2024-01-02 00:00:00
End                       2024-12-30 00:00:00
Duration                    363 days 00:00:00
Exposure Time [%]                         0.0
Equity Final [$]                   13887.7882
Equity Peak [$]                   14261.56093
Return [%]                           38.87788
Buy & Hold Return [%]                36.51989
Return (Ann.) [%]                    39.05972
Volatility (Ann.) [%]                31.28991
CAGR [%]                              25.6082
Sharpe Ratio                          1.24832
Sortino Ratio                         2.76419
Calmar Ratio                          2.55955
Alpha [%]                             2.74259
Beta                                  0.98947
Max. Drawdown [%]                   -15.26037
Avg. Drawdown [%]                     -3.3972
Max. Drawdown Duration      134 days 00:00:00
Avg. Drawdown Duration       22 days 00:00:00
# Trades                                    0
Win Rate [%]                              NaN
Best Trade [%]                            NaN
Worst Trade [%]                           NaN
Avg. Trade [%]                            NaN
Max. Trade Duration                       NaN
Avg. Trade Duration                       NaN
Profit Factor                             NaN
Expectancy [%]                            NaN
SQN                                       NaN
Kelly Criterion                           NaN
_strategy                          MyStrategy
_equity_curve                             ...
_trades                   Empty DataFrame
...
dtype: object
TRADES_TABLE
| Size   | EntryBar   | ExitBar   | EntryPrice   | ExitPrice   | SL   | TP   | PnL   | Commission   | ReturnPct   | EntryTime   | ExitTime   | Duration   | Tag   |
|--------|------------|-----------|--------------|-------------|------|------|-------|--------------|-------------|-------------|------------|------------|-------|
TRADES_CSV
Size,EntryBar,ExitBar,EntryPrice,ExitPrice,SL,TP,PnL,Commission,ReturnPct,EntryTime,ExitTime,Duration,Tag

EQUITY_CSV
Equity,DrawdownPct,DrawdownDuration
10000.0,0.0,
10000.0,0.0,
9986.91134960598,0.001308865039401974,
9947.097277950706,0.0052902722049293915,
10185.974154781761,0.0,5 days
10163.068957638206,0.0022486997115344076,
10220.33404858059,0.0,2 days
10187.612338375511,0.003201628249090649,
10205.609698605003,0.0014406916550473436,
10080.716662716331,0.013660745842612454,
10028.904910396996,0.018730223226918863,
10353.409610104027,0.0,8 days
10513.205523800316,0.0,
10640.278888058128,0.0,
10710.63350231594,0.0,
10673.547778438988,0.003462514506628822,
10655.550418209496,0.005142840906145696,
10560.106921505394,0.01405393815202427,
10522.475695919456,0.017567383512450463,
10321.23004467434,0.03635671574024091,
10122.711062740746,0.05489147205420386,
10256.876788448753,0.04236506774030435,
10201.792025875511,0.047508065356769436,
10301.596179317894,0.038189834701150116,
10389.948993038597,0.029940760199478667,
10395.948672604027,0.029380599162866505,
10336.501574825706,0.03493088689939172,
10378.54968578762,0.031005058333525737,
10285.71620495266,0.03967247103277338,
10170.492816280785,0.050430321037346904,
10121.891131710472,0.05496802504521936,
10106.055636715355,0.05644650855337918,
10021.413073849144,0.06434917489406844,
9980.456805538597,0.06817306339717988,
10021.960254024925,0.06429808732995157,
10133.904757809105,0.05384637093428046,
10032.881198238792,0.06327845163692691,
9958.614917110863,0.0702123347832293,
10038.886752438011,0.062717742114197,
9972.81222851223,0.0688868005467812,
9936.225848507347,0.07230269373339537,
9876.703219723167,0.0778600334342926,
9627.691760372581,0.10110902793090593,
9355.744052242699,0.1264994689418023,
9301.135974239769,0.13159796082756436,
9294.583239864769,0.13220975791441114,
9389.05490429348,0.12338939594345177,
9499.362063717308,0.1130905504643327,
9525.573001217308,0.1106433621169457,
9410.89931042141,0.12134988949192338,
9513.01387340969,0.11181594708168208,
9492.263827633324,0.11375327840497684,
9552.331958126488,0.10814500785028225,
9681.207156490746,0.09611255446305811,
9822.640643429222,0.08290759446625728,
9424.003100704613,0.12012645202854921,
9473.696627926292,0.11548680795792221,
9395.60763866848,0.122777598856605,
9333.354144405785,0.12858990624712807,
9529.942050289574,0.11023544515560801,
9430.010333370628,0.11956558579549992,
9350.829501461449,0.12695831675693736,
9285.845980953636,0.1330255134819267,
9330.077777218285,0.12889580479055152,
9284.754138302269,0.13312745354468125,
9326.2559083218,0.12925263418777233,
9264.54791576809,0.13501401072449792,
9331.169619869652,0.12879386472779697,
9227.961535763206,0.1384299039111122,
9624.413714718285,0.10141508318464865,
9706.87343151516,0.0937162186143089,
9496.085696529808,0.11339644900775603,
9315.334124874535,0.13027234823595668,
9239.976001095238,0.1373081714450135,
9187.551608395042,0.14220278320526658,
9076.15092785305,0.1526037254574596,
9122.021746944847,0.148320989139213,
9179.906192135277,0.1429165987100275,
9295.675082516136,0.1321078178516566,
9343.184085201683,0.12767213226169827,
9310.965075802269,0.13068026519729425,
9540.318332027855,0.10926666196122115,
9367.211337398949,0.12542882403982047,
9310.965075802269,0.13068026519729425,
9514.65289623684,0.11166291945481066,
10079.843020748558,0.058893853611085456,
9988.648562740746,0.0674082386834618,
10026.328463863792,0.06389024872377369,
10044.894824337425,0.06215679752598802,
10144.827380489769,0.05282657853093642,
10075.380816769066,0.0593104679951485,
10252.003360104027,0.04282007615261463,
10314.888797115746,0.036948767326846155,
10440.109973263206,0.02525747230490516,
10446.67193920559,0.02464481331130186,
10448.312640499535,0.024491628974111057,
10512.289080929222,0.018518458440747843,
10583.923526119652,0.011830297075228202,
10504.634433102074,0.01923313585226538,
10284.81318981594,0.03975678118459802,
10454.327426266136,0.023930057544624628,
10454.874606441917,0.023878969980507758,
10471.278262447777,0.022347440029239052,
10525.961032223167,0.01724197453426468,
10578.455920528831,0.012340780940597873,
10675.788531612816,0.0032533062302608773,
10693.287387203636,0.001619522795598738,
10776.40338451809,0.0,134 days
10700.394854855003,0.007053237239827537,
10832.179675411644,0.0,2 days
10626.027026485863,0.01903150197865855,
11393.214755367699,0.0,4 days
11716.933932613792,0.0,
11780.911212276878,0.0,
11685.216784786644,0.008122837509420444,
11913.787036251488,0.0,4 days
11783.64375622219,0.010923754103820627,
11531.560702633324,0.03208268978244444,
11411.807971310081,0.042134298977644535,
11447.350344967308,0.03915100126138715,
11498.206210445824,0.034882344676896326,
11726.775622677269,0.015697058626713445,
11773.255725216331,0.011795687685833611,
11582.961230587425,0.02776831620855902,
11918.161959957542,0.0,14 days
12110.642657589378,0.0,
12180.635562252464,0.0,
12442.561145138206,0.0,
12523.49093944973,0.0,
12570.517382931175,0.0,
12805.649600338402,0.0,
12509.82150585598,0.023101373512094514,
12672.224917721214,0.01041920455278278,
12883.297992062035,0.0,5 days
12906.265292477074,0.0,
12581.454272579613,0.025166925716829214,
12324.448275875511,0.04508019968725563,
12331.557421993675,0.044529370616485764,
12312.419543575706,0.04601220689671659,
12369.834018063011,0.041563633030753055,
12016.042590450706,0.0689760114062794,
11958.626437496605,0.07342471532278494,
11984.327960323753,0.07143331639794415,
11999.639773678246,0.07024693032827167,
12030.260043453636,0.06787441829001084,
12209.616809200706,0.053977542494995534,
12006.200061153831,0.06973862778474582,
12088.22253735012,0.06338338292207446,
11509.142260860863,0.10825153520054942,
11397.589679073753,0.11689482427443298,
11539.21618969387,0.10592135461371943,
11730.056186031761,0.09113473803540306,
11890.275073360863,0.07872069852061858,
11974.581942867699,0.07218845487024383,
12179.330554317894,0.0563241744753924,
12203.963733028831,0.054415552720553984,
12368.200869869652,0.041690172208148746,
12441.01192028469,0.036048644720140244,
12432.252841305199,0.03672731347372593,
12466.193957638206,0.03409749643805793,
12460.172458004417,0.034564052757592,
12357.79773266262,0.04249622546765319,
12484.26013500637,0.032697697428913486,
12502.873492550316,0.03125550194306714,
12549.407306026878,0.027649980715815925,
12465.099597286644,0.03418228939146173,
12645.75885326809,0.020184494375830808,
12602.509799313011,0.023535506692328623,
12261.447863888206,0.04996158175709631,
12156.337237667503,0.058105736850667,
12240.097766231956,0.05161582465172321,
12154.694018673363,0.058233056331314814,
12159.62115795559,0.05785129296518454,
12115.82492382473,0.06124470175838426,
12255.426364254417,0.05042813807663038,
12261.447863888206,0.04996158175709631,
12246.665606808128,0.05110693688075818,
11908.340411495628,0.0773209645367452,
11934.070468258324,0.07532735475268992,
12147.577319454613,0.058784470629523855,
12595.393100094261,0.024086920990537553,
12558.713565182152,0.026928915485528226,
12464.005236935081,0.03426708234486553,
12513.274112057152,0.030449643759375755,
12458.529239010277,0.034691372238239815,
12521.486850094261,0.02981330645722091,
12536.267428707542,0.02866808138410104,
12821.49013073391,0.006568527751601327,
12449.771838497581,0.0353699109412835,
12480.976214718285,0.032952141314396055,
12420.208163570824,0.03766055616333619,
12482.069735836449,0.0328674133862632,
12202.323031734886,0.05454267712538874,
12425.68332226223,0.03723633129523296,
12632.07263500637,0.02124492649554688,
12604.699359249535,0.023365855760249965,
12523.130069088402,0.029685986976573098,
12728.424182247581,0.013779440155561762,
12868.023944210472,0.002963006524349998,
12754.702258419456,0.011743368869533644,
12774.957156490746,0.010173983953581489,
12930.980716061058,0.0,94 days
13012.003665279808,0.0,
12978.0625489468,0.0026084465702675974,
12698.860507320824,0.024065713937243216,
12688.460727047386,0.024864959045142188,
12734.446521114769,0.021330853518405468,
12843.389087032738,0.012958386931367638,
12858.170504879417,0.011822403709496832,
12662.729831051292,0.02684243281920451,
12433.347201656761,0.04447097299604119,
12269.111743282738,0.05709281530402144,
12219.840350460472,0.06087942604359087,
12298.673739742699,0.05482091335714134,
12258.709445309105,0.05789225390250485,
12519.297290157738,0.03786552692394085,
12504.499926876488,0.039002735586180504,
12354.880557369652,0.05050130055400859,
12354.880557369652,0.05050130055400859,
12403.65680248684,0.04675274296273313,
12573.55456860012,0.03369574033010847,
12397.080569576683,0.04725814036956788,
12562.59250194973,0.03453819833522265,
12576.842685055199,0.033443041626691095,
12616.302600216331,0.030410463695098255,
12589.99599010891,0.032432182316160074,
12663.98280651516,0.026746139004961922,
12828.399539303246,0.014110365374894296,
12948.423343014183,0.004886282228407146,
12941.298251461449,0.0054338605826729225,
13072.831301998558,0.0,39 days
13196.692080807152,0.0,
13364.396930050316,0.0,
13384.127307247581,0.0,
13385.770526241722,0.0,
13374.80929882473,0.0008188716066440671,
13589.099154781761,0.0,4 days
13645.001330685081,0.0,
13574.85065014309,0.005141126691152187,
13655.414538692894,0.0,2 days
13664.730868648949,0.0,
13824.214587521019,0.0,
13957.939715694847,0.0,
13660.346713375511,0.021320696920958282,
13755.707965206566,0.014488653383484928,
14013.294711422386,0.0,3 days
14056.042743038597,0.0,
14216.623339962425,0.0,
14261.56093151516,0.0,
14073.579364132347,0.013180995284142516,
13887.788195919456,0.026208402950461118,4 days

SUMMARY_JSON
{"end": "2024-12-30 00:00:00", "initial": 10000.0, "equity_final": 13887.788195919456, "portfolio_final": 13887.788195919456, "pnl_abs": 3887.7881959194565, "pnl_pct": 38.87788195919457}


